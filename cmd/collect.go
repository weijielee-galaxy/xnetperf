package cmd

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sync"
	"xnetperf/config"

	"github.com/spf13/cobra"
)

var cleanupRemote bool

var collectCmd = &cobra.Command{
	Use:   "collect",
	Short: "Collect report files from remote hosts",
	Long: `Collect report JSON files generated by ib_write_bw from all configured hosts
and organize them in local reports directory by hostname.

The --cleanup flag can be used to automatically delete remote report files 
after successful collection. Use with caution as this operation is irreversible.

Examples:
  # Collect files without cleanup
  xnetperf collect

  # Collect files and cleanup remote files after success
  xnetperf collect --cleanup`,
	Run: func(cmd *cobra.Command, args []string) {
		cfg, err := config.LoadConfig(cfgFile)
		if err != nil {
			fmt.Printf("Error reading config: %v\n", err)
			os.Exit(1)
		}

		if !cfg.Report.Enable {
			fmt.Println("Report is not enabled in config. No files to collect.")
			return
		}

		execCollectCommand(cfg)
	},
}

func init() {
	collectCmd.Flags().BoolVar(&cleanupRemote, "cleanup", false, "Delete remote report files after successful collection")
}

func cleanupLocalFiles(reportsDir string, hosts map[string]bool) {
	fmt.Printf("Cleaning up existing local report files...\n")

	for hostname := range hosts {
		hostDir := filepath.Join(reportsDir, hostname)

		// Ê£ÄÊü•‰∏ªÊú∫ÁõÆÂΩïÊòØÂê¶Â≠òÂú®
		if _, err := os.Stat(hostDir); os.IsNotExist(err) {
			continue // ÁõÆÂΩï‰∏çÂ≠òÂú®ÔºåË∑≥Ëøá
		}

		// Êü•ÊâæËØ•‰∏ªÊú∫ÁöÑÊâÄÊúâJSONÊñá‰ª∂
		pattern := filepath.Join(hostDir, "*.json")
		files, err := filepath.Glob(pattern)
		if err != nil {
			fmt.Printf("   [WARNING] ‚ö†Ô∏è  %s: Error finding local files: %v\n", hostname, err)
			continue
		}

		if len(files) > 0 {
			// Âà†Èô§ÊâæÂà∞ÁöÑÊñá‰ª∂
			for _, file := range files {
				if err := os.Remove(file); err != nil {
					fmt.Printf("   [WARNING] ‚ö†Ô∏è  %s: Failed to remove %s: %v\n", hostname, file, err)
				}
			}
			fmt.Printf("   [CLEANUP] üßπ %s: Removed %d existing local files\n", hostname, len(files))
		}
	}
	fmt.Println()
}

func execCollectCommand(cfg *config.Config) error {
	// ÂàõÂª∫Êú¨Âú∞reportsÁõÆÂΩï
	reportsDir := "reports"
	err := os.MkdirAll(reportsDir, 0755)
	if err != nil {
		fmt.Printf("Error creating reports directory: %v\n", err)
		return err
	}

	// Ëé∑ÂèñÊâÄÊúâ‰∏ªÊú∫ÂàóË°®
	allHosts := make(map[string]bool)
	for _, host := range cfg.Server.Hostname {
		allHosts[host] = true
	}
	for _, host := range cfg.Client.Hostname {
		allHosts[host] = true
	}

	// Âú®Êî∂ÈõÜÂâçÊ∏ÖÁêÜÊú¨Âú∞Â∑≤Â≠òÂú®ÁöÑÊä•ÂëäÊñá‰ª∂
	cleanupLocalFiles(reportsDir, allHosts)

	var wg sync.WaitGroup
	fmt.Printf("Collecting reports from %d hosts...\n", len(allHosts))

	for hostname := range allHosts {
		wg.Add(1)
		go func(host string) {
			defer wg.Done()
			collectFromHost(host, cfg.Report.Dir, reportsDir)
		}(hostname)
	}

	wg.Wait()
	fmt.Printf("Report collection completed. Files saved to '%s' directory.\n", reportsDir)
	return nil
}

func collectFromHost(hostname, remoteDir, localBaseDir string) {
	// ‰∏∫ÊØè‰∏™‰∏ªÊú∫ÂàõÂª∫Êú¨Âú∞Â≠êÁõÆÂΩï
	hostDir := filepath.Join(localBaseDir, hostname)
	err := os.MkdirAll(hostDir, 0755)
	if err != nil {
		fmt.Printf("Error creating directory for host %s: %v\n", hostname, err)
		return
	}

	fmt.Printf("-> Collecting reports from %s...\n", hostname)

	// ‰ΩøÁî®scpÊî∂ÈõÜÂ±û‰∫éÂΩìÂâç‰∏ªÊú∫ÁöÑJSONÊä•ÂëäÊñá‰ª∂ÔºàÊåâ‰∏ªÊú∫ÂêçÂåπÈÖçÔºâ
	// scp hostname:remoteDir/*hostname*.json localDir/
	scpCmd := fmt.Sprintf("%s/*%s*.json", remoteDir, hostname)
	cmd := exec.Command("scp", fmt.Sprintf("%s:%s", hostname, scpCmd), hostDir+"/")

	output, err := cmd.CombinedOutput()
	if err != nil {
		// Ê£ÄÊü•ÊòØÂê¶ÊòØÂõ†‰∏∫Ê≤°ÊúâÂåπÈÖçÁöÑÊñá‰ª∂
		if string(output) != "" {
			fmt.Printf("   [WARNING] ‚ö†Ô∏è  %s: %s\n", hostname, string(output))
		} else {
			fmt.Printf("   [WARNING] ‚ö†Ô∏è  %s: No report files found or scp failed: %v\n", hostname, err)
		}
		return
	}

	// ËÆ°ÁÆóÊî∂ÈõÜÂà∞ÁöÑÊñá‰ª∂Êï∞Èáè
	files, err := filepath.Glob(filepath.Join(hostDir, "*.json"))
	if err != nil {
		fmt.Printf("   [ERROR] ‚ùå %s: Error counting files: %v\n", hostname, err)
		return
	}

	if len(files) > 0 {
		fmt.Printf("   [SUCCESS] ‚úÖ %s: Collected %d report files\n", hostname, len(files))

		// ‰ªÖÂú®ÂêØÁî®cleanupÊ†áÂøóÊó∂Ê∏ÖÁêÜËøúÁ®ã‰∏ªÊú∫‰∏äÁöÑÊä•ÂëäÊñá‰ª∂
		if cleanupRemote {
			cleanupRemoteFiles(hostname, remoteDir)
		}
	} else {
		fmt.Printf("   [INFO] ‚ÑπÔ∏è  %s: No report files found\n", hostname)
	}
}

func cleanupRemoteFiles(hostname, remoteDir string) {
	fmt.Printf("   [CLEANUP] üßπ %s: Cleaning up remote report files...\n", hostname)

	// È¶ñÂÖàÊ£ÄÊü•ËøúÁ®ãÁõÆÂΩï‰∏≠ÊòØÂê¶ËøòÊúâÂ±û‰∫éÂΩìÂâç‰∏ªÊú∫ÁöÑJSONÊñá‰ª∂
	checkCmd := fmt.Sprintf("ls %s/*%s*.json 2>/dev/null | wc -l", remoteDir, hostname)
	checkExec := exec.Command("ssh", hostname, checkCmd)

	checkOutput, err := checkExec.CombinedOutput()
	if err != nil {
		fmt.Printf("   [WARNING] ‚ö†Ô∏è  %s: Failed to check remote files: %v\n", hostname, err)
		return
	}

	// Â¶ÇÊûúÊ≤°ÊúâÊñá‰ª∂ÈúÄË¶ÅÊ∏ÖÁêÜÔºåÂàôË∑≥Ëøá
	if string(checkOutput) == "0\n" {
		fmt.Printf("   [CLEANUP] ‚ÑπÔ∏è  %s: No remote files to cleanup\n", hostname)
		return
	}

	// ‰ΩøÁî®SSHÂà†Èô§ËøúÁ®ã‰∏ªÊú∫‰∏äÂ±û‰∫éÂΩìÂâç‰∏ªÊú∫ÁöÑJSONÊä•ÂëäÊñá‰ª∂ÔºàÂÆâÂÖ®ÂåπÈÖçÔºâ
	rmCmd := fmt.Sprintf("rm -f %s/*%s*.json", remoteDir, hostname)
	cmd := exec.Command("ssh", hostname, rmCmd)

	output, err := cmd.CombinedOutput()
	if err != nil {
		fmt.Printf("   [WARNING] ‚ö†Ô∏è  %s: Failed to cleanup remote files: %v\n", hostname, err)
		if len(output) > 0 {
			fmt.Printf("   [WARNING] ‚ö†Ô∏è  %s: SSH output: %s\n", hostname, string(output))
		}
		return
	}

	// È™åËØÅÊ∏ÖÁêÜÊòØÂê¶ÊàêÂäü
	verifyCmd := fmt.Sprintf("ls %s/*%s*.json 2>/dev/null | wc -l", remoteDir, hostname)
	verifyExec := exec.Command("ssh", hostname, verifyCmd)

	verifyOutput, err := verifyExec.CombinedOutput()
	if err == nil && string(verifyOutput) == "0\n" {
		fmt.Printf("   [CLEANUP] ‚úÖ %s: Remote files cleaned up successfully\n", hostname)
	} else {
		fmt.Printf("   [WARNING] ‚ö†Ô∏è  %s: Cleanup verification failed\n", hostname)
	}
}
